(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{106:function(a,t,e){"use strict";e.r(t);var r=e(0),v=Object(r.a)({},function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"react-native-작동-구조"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-native-작동-구조","aria-hidden":"true"}},[a._v("#")]),a._v(" React Native 작동 구조")]),a._v(" "),e("p",[a._v("'"),e("strong",[a._v("어떻게 JavaScript와 Native가 인터랙션 가능한가?")]),a._v("'에 대한 궁금증을 풀어 줄 내용입니다.")]),a._v(" "),e("base-img",{attrs:{src:"react-native-infra.jpg"}}),a._v(" "),e("h2",{attrs:{id:"react-native-인프라스트럭처"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-native-인프라스트럭처","aria-hidden":"true"}},[a._v("#")]),a._v(" React Native 인프라스트럭처")]),a._v(" "),e("p",[a._v("React Native로 작성한 앱이 네이티브 앱으로 작동 가능한 이유는 React Native 인프라스트럭처 위에서 동작 하기 때문입니다. 인프라스트럭처는 커스텀 코드가 실행되기 전에 앱을 실행 할 때 마다 빌드됩니다. 다시 말해 "),e("strong",[a._v("React Native가 앱 기반을 구축하기 위한 작업이 안 보이는 곳에서 바쁘게 진행됩니다.")])]),a._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",[a._v("'"),e("a",{attrs:{href:"https://ko.wikipedia.org/wiki/%EA%B8%B0%EB%B0%98_%EC%8B%9C%EC%84%A4",target:"_blank",rel:"noopener noreferrer"}},[a._v("인프라스트럭처(Infrastructure, 또는 인프라)"),e("OutboundLink")],1),a._v("'는 애플리케이션의 작동 기반을 형성하는 시스템을 말합니다.")])]),a._v(" "),e("p",[a._v("다음 그림은 React Native 인프라스트럭처 구조를 보여줍니다. (왼쪽 JAVA 로고는 Android 네이티브 개발 환경을 보여주며, iOS의 경우 Objective-C로 변경될 수 있습니다)\n그림에서 볼 수 있듯이 다소 복잡해 보이는 프로세스를 거쳐 JavaScript로 개발된 코드가 네이티브 앱에서 작동 가능한 코드로 변경됩니다.")]),a._v(" "),e("base-img",{attrs:{src:"react-native-Infrastructure.png"}}),a._v(" "),e("h2",{attrs:{id:"react-native-앱-시작-→-빌드"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-native-앱-시작-→-빌드","aria-hidden":"true"}},[a._v("#")]),a._v(" React Native 앱 시작 → 빌드")]),a._v(" "),e("p",[a._v("인프라스트럭처는 React Native 앱이 시작될 때마다 빌드 되고,\n앱을 구동하기 위해 다음의 2가지를 필요로 합니다.")]),a._v(" "),e("ul",[e("li",[e("strong",[a._v("애플리케이션 코드")])]),a._v(" "),e("li",[e("strong",[a._v("메인 스레드(또는 UI 스레드)")]),a._v(": 모바일 OS에서 할당 받은 고유 스레드")])]),a._v(" "),e("h3",{attrs:{id:"빌드-코드"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#빌드-코드","aria-hidden":"true"}},[a._v("#")]),a._v(" 빌드 코드")]),a._v(" "),e("p",[a._v("인프라스트럭처 빌드 코드는 개념적으로 다음과 같이 프레임 워크 또는 커스텀 코드로 나뉘고,\n각 코드는 다시 JavaScript 코드와 Native 코드로 나눌 수 있어 총 4개 영역으로 분류할 수 있습니다.")]),a._v(" "),e("ul",[e("li",[e("strong",[a._v("프레임 워크 코드")]),a._v(" → "),e("span",{staticStyle:{color:"#7e7e7e"}},[a._v("매번 작성하지 않아도 되는 코드")]),a._v(" "),e("ul",[e("li",[a._v("JavaScript 코드")]),a._v(" "),e("li",[a._v("Native 코드")])])]),a._v(" "),e("li",[e("strong",[a._v("커스텀 코드")]),a._v(" → "),e("span",{staticStyle:{color:"#7e7e7e"}},[a._v("개발자가 작성하는 코드")]),a._v(" "),e("ul",[e("li",[a._v("JavaScript 코드")]),a._v(" "),e("li",[a._v("Native 코드")])])])]),a._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",[a._v("메인 스레드(또는 UI 스레드)에서 먼저 처리되는 것은 프레임 워크의 Native 코드 부분입니다.")])]),a._v(" "),e("br"),a._v(" "),e("h2",{attrs:{id:"native-기반-형성"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#native-기반-형성","aria-hidden":"true"}},[a._v("#")]),a._v(" Native 기반 형성")]),a._v(" "),e("p",[e("strong",[a._v("React Native로 작성하는 UI 코드는 JavaScript를 사용하지만, 최종적으로는 네이티브 뷰(Native View)로 렌더링 됩니다.")]),a._v("\nReact Native는 '네이티브 뷰'로 렌더링 하기 위해 다음의 2가지를 수행합니다.")]),a._v(" "),e("ol",[e("li",[a._v("'네이티브 뷰'를 만들고, JavaScript 컴포넌트와 연결")]),a._v(" "),e("li",[a._v("생성한 '네이티브 뷰'를 저장하고, 앱 화면에 렌더링")])]),a._v(" "),e("h3",{attrs:{id:"ui-관리-모듈-루트-뷰"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ui-관리-모듈-루트-뷰","aria-hidden":"true"}},[a._v("#")]),a._v(" UI 관리 모듈 / 루트 뷰")]),a._v(" "),e("p",[a._v("1단계가 UI 관리 모듈(UIManagerModule)에 의해 처리되는 동안, 루트 뷰(RootView)는 2단계를 처리합니다.\n'루트 뷰'는 '네이티브 뷰'를 구성하는 컨테이너(JavaScript 컴포넌트의 Native 표현 방식) 역할을 말합니다.\n앱 화면에 표시되는 모든 것은 '루트 뷰' 안에 포함됩니다.")]),a._v(" "),e("base-img",{staticStyle:{"max-width":"300px","margin-left":"0"},attrs:{src:"rootview.png"}}),a._v(" "),e("p",[a._v("초기화 단계에서 모든 것은 브리지 인터페이스(Bridge Interface)로 이동하기 전에 '루트 뷰'에서 시작합니다.\n'루트 뷰'를 포함한 대부분의 Native 코드는 특정 플랫폼에 맞는 언어(JAVA, Objective-C)로 작성되어 있어도\n브리지는 "),e("strong",[a._v("전부 C++로 구현화")]),a._v(" 되어 있습니다. 그래서 "),e("strong",[a._v('브리지 인터페이스는 Native와 JavaScript가\n서로 인터랙션 할 수 있도록 "다리(Bridge)" 역할을')]),a._v(" 합니다. 브리지는 2개의 엔드 포인트를 가집니다.")]),a._v(" "),e("ul",[e("li",[a._v("Native → JavaScript")]),a._v(" "),e("li",[a._v("Native ← JavaScript")])]),a._v(" "),e("base-img",{staticStyle:{"max-width":"620px","margin-left":"0"},attrs:{src:"rn-bridge.png"}}),a._v(" "),e("div",{staticClass:"warning custom-block"},[e("p",[a._v("하지만 디스패치(dispatch) 호출을 할 수 있는 엔드 포인트가 없다면 브리지는 아무런 의미가 없습니다."),e("br"),a._v("\n즉, Native 모듈을 제외한 모든 것은 애플리케이션에서 보이지 않게 됩니다.")])]),a._v(" "),e("h3",{attrs:{id:"uimanagermodule"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#uimanagermodule","aria-hidden":"true"}},[a._v("#")]),a._v(" UIManagerModule")]),a._v(" "),e("p",[a._v("이런 이유로 프레임 워크 코드에는 핵심 모듈(Core Modules)이 포함되어 있습니다. 핵심 모듈 중 하나는 UIManagerModule 입니다.\nUIManagerModule은 JavaScript로 구성된 모든 UI 컴포넌트와 연관된 '네이티브 뷰'와의 매핑 정보를 저장합니다.")]),a._v(" "),e("base-img",{staticStyle:{"max-width":"300px","margin-left":"0","margin-bottom":"20px"},attrs:{src:"core-modules.png"}}),a._v(" "),e("p",[a._v("예를 들어 JavaScript로 작성된 UI 컴포넌트가 생성 되거나, 업데이트 되거나, 제거 될 때마다 UIManagerModule에 저장된 매핑 정보를 이용해\n'네이티브 뷰'를 생성/업데이트/제거 합니다. 그리고 앱 화면을 렌더링 하기 위한 변경 사항을 '루트 뷰'에 저장된 '네이티브 뷰' 트리에 전달합니다.")]),a._v(" "),e("p",[a._v("초기화 관점에서 보면 모든 Native 모듈은 동일하게 처리됩니다. 각 모듈은 인스턴스를 만들고 인스턴스에 대한 레퍼런스가 JavaScript에서\nNative 브리지에 저장되고, 추후 JavaScript에 의해 호출될 수 있습니다. 그리고 브리지 인터페이스에 대한 레퍼런스가 각 Native 모듈에\n전달 될 수 있어 직접 JavaScript를 호출할 수도 있습니다.\n최종적으로 2개의 추가 스레드가 생성됩니다. 하나는 JavaScript 스레드, 다른 하나는 Native 모듈 스레드 입니다.")]),a._v(" "),e("h2",{attrs:{id:"javascript-엔진-설정"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript-엔진-설정","aria-hidden":"true"}},[a._v("#")]),a._v(" JavaScript 엔진 설정")]),a._v(" "),e("p",[a._v("앞서 설명한 내용을 간단히 요약하면 다음과 같습니다.")]),a._v(" "),e("ul",[e("li",[a._v("메인(UI) 스레드는 Native와 관련된 것을 생성")]),a._v(" "),e("li",[a._v("3개의 스레드를 이용 (메인 스레드, NativeModules 스레드, JavaScript 스레드)")]),a._v(" "),e("li",[a._v("아직 JavaScript는 처리 ✘")])]),a._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",[a._v("※ 이미지 맵을 참고하세요.")]),a._v(" "),e("base-img",{staticStyle:{"max-width":"450px","margin-left":"0"},attrs:{src:"react-native-Infrastructure2.png"}})],1),a._v(" "),e("h3",{attrs:{id:"javascript-vm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript-vm","aria-hidden":"true"}},[a._v("#")]),a._v(" JavaScript VM")]),a._v(" "),e("p",[a._v("Native 앱 환경에서 JavaScript로 작성된 코드를 그대로 실행할 수 없습니다. 바이트 코드로 변환한 후에야\n실행 가능합니다. 코드 변환 과정은 JavaScript 가상머신(VM, Virtual Machine)에 의해 처리됩니다.\nJavaScript 엔진은 Chrome V8, Safari JavaScript Core 등 다양합니다.")]),a._v(" "),e("base-img",{staticStyle:{"max-width":"500px",margin:"-17px auto"},attrs:{src:"browser-engine.png"}}),a._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",[a._v("iOS 앱은 Safari JavaScript Core를, 하지만 Android 앱은 Safari JavaScript Core가 포함되어 있지 않아\nReact Native는 번들링 과정에서 JS Core 복사본을 포함합니다. 그것이 React Native로 만든\nAndroid 앱이 iOS 앱보다 다소 무거운 이유입니다.")])]),a._v(" "),e("h3",{attrs:{id:"실행-컨텍스트"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#실행-컨텍스트","aria-hidden":"true"}},[a._v("#")]),a._v(" 실행 컨텍스트")]),a._v(" "),e("p",[a._v("React Native는 JavaScript 엔진을 효과적으로 실행하기 위해 실행 환경에 대한 컨텍스트(Context)를\n제공해야 합니다. JavaScript 글로벌(Global) 객체를 포함해야 하고, 사실상 C++ 브리지에 생성되고\n저장됩니다. 이것은 매우 중요한 과정인데 "),e("strong",[a._v("글로벌 객체는 JavaScript 환경 뿐만 아니라, 외부에서도 접근\n가능하기 때문입니다.")])]),a._v(" "),e("base-img",{staticStyle:{"max-width":"500px","margin-left":"0"},attrs:{src:"JS-global-object.png"}}),a._v(" "),e("h3",{attrs:{id:"글로벌-객체"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#글로벌-객체","aria-hidden":"true"}},[a._v("#")]),a._v(" 글로벌 객체")]),a._v(" "),e("p",[a._v("글로벌 객체는 C++(Native)와 JavaScript 간의 기본적인 통신 수단이며, JavaScript에서 Native로 전달 하는데 사용되는 모든 기능은\n글로벌 객체를 통해 이루어집니다. 글로벌 객체에는 많은 것이 담겨있지만, ModuleConfig 배열과 flushQueue() 함수가 중요한 역할을 합니다.")]),a._v(" "),e("p",[a._v("ModuleConfig 배열의 각 아이템은 Native 모듈(코어 또는 커스텀)에 대한 정보를 기술하며 이름, 외부로 노출되는 상수, 함수 등을 포함합니다.\nflushQueue() 함수는 JavaScript와 Native 환경 간 통신을 보장하게 해주는 중요한 역할을 수행하며, 주기적으로 호출 과정에 사용됩니다.")]),a._v(" "),e("p",[a._v("JavaScript 컨텍스트가 완전히 생성되고 채워지면, JavaScript 엔진으로 보내집니다. 그리고 JavaScript 스레드에서\nReact Native JavaScript 번들 로딩을 시도합니다.")]),a._v(" "),e("h2",{attrs:{id:"javascript-번들-로딩"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript-번들-로딩","aria-hidden":"true"}},[a._v("#")]),a._v(" JavaScript 번들 로딩")]),a._v(" "),e("p",[a._v("JavaScript VM이 프레임 워크의 JavaScript 부분을 처리하기 시작하면 BatchedBridge를 생성합니다. BatchedBridge는\n단순한 큐(Queue)에 불과하며 'JavaScript에서 Native 호출을 저장'하는 역할을 수행합니다.")]),a._v(" "),e("p",[a._v("'호출'이란? Native 모듈 ID, 메서드 ID, 그리고 인자를 포함하는 객체입니다. BatchedBridge는 주기적(대략 5ms 마다)으로 global.flushQueue()를 호출하는데\n콘텐츠('호출' 배열)를 JavaScript에서 C++ 브리지(Native)로 보냅니다.")]),a._v(" "),e("base-img",{staticStyle:{"max-width":"450px","margin-left":"0"},attrs:{src:"batch-bridge.png"}}),a._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",[a._v("배치(batch)로 불리는 이 작은 배열은 모든 UI 변경 사항을\n동시에 표시하도록 인덱싱 되어 있습니다. 전체 프로세스가 비동기 이기 때문입니다.\n브리지의 Native 엔드에 대한 JavaScript가 일괄적으로 각 호출에 걸쳐 반복되며, 특정 모듈 ID를 이용해 적절한 Native 모듈에\n디스패치 합니다.")])]),a._v(" "),e("h3",{attrs:{id:"nativemodules"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nativemodules","aria-hidden":"true"}},[a._v("#")]),a._v(" NativeModules")]),a._v(" "),e("p",[a._v("다음 단계는 NativeModules 객체를 만드는 것입니다. 이 단계는 Native를 호출할 때마다 React Native로부터 추가되어야 하는 객체를 생성합니다.\nNativeModules 객체는 앞서 언급한 ModuleConfig 배열을 이용해 채워집니다. 이 과정은 대체적으로 ModuleConfig 안에 포함된 각 module_name에 대해\n아래와 같이 처리하고,")]),a._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[a._v("NativeModules"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("module_name"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("그리고 각 모듈로부터 외부로 노출된 Native 메서드에 대해서는 다음과 같이 처리하는 것과 동일합니다.")]),a._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[a._v("NativeModules"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("module_name"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("method_name"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" fillterMethod\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("fillterMethod는 BatchedBridge에서 받은 모든 인수를 저장하기 위해 존재하며 메서드 및 모듈 ID를 포함합니다.")]),a._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function-variable function"}},[a._v("fillterMethod")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("...")]),a._v("args")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  BatchedBridge"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("enqueueNativeCall")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("moduleID"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" methodID"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" args"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br")])]),e("p",[a._v("이러한 방법을 사용해 JavaScript에서 Native로 가는 '호출'을 효과적으로 생성하도록 합니다.\nMyNativeModule.myMethod(args)를 작성하는 것은 실제로는 fillterMethod 입니다.")]),a._v(" "),e("h3",{attrs:{id:"js-modules"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-modules","aria-hidden":"true"}},[a._v("#")]),a._v(" JS Modules")]),a._v(" "),e("p",[a._v("마지막은 JavaScript Core 모듈을 만드는 것입니다. Core 모듈은 이벤트를 Native에서 JavaScript로\n보내는데 사용되는 디바이스 이벤트 이미터(DeviceEventEmitter)와 앱의 메인 컴포넌트에 대한 레퍼런스 정보를 저장하는 앱 레지스트리(AppRegistry)를\n포함하고 있습니다. Native에서 호출 가능하게 하기 위해 이 모듈들은 JavaScript 글로벌 객체에 등록 됩니다.\n이로서 인프라스트럭처는 완성됩니다.")]),a._v(" "),e("br"),a._v(" "),e("h2",{attrs:{id:"react-native-앱-렌더링"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-native-앱-렌더링","aria-hidden":"true"}},[a._v("#")]),a._v(" React Native 앱 렌더링")]),a._v(" "),e("p",[a._v("초기화를 완료했음에도 아직 이 단계에서는 앱이 화면 상에 렌더링 되지 않습니다. 사실 JavaScript 번들을 로딩하는 것은\nJavaScript 스레드에서 일어나는데 이는 메인 스레드(UI 스레드)와는 독립적입니다.")]),a._v(" "),e("p",[a._v("그래서 JavaScript 스레드는 프로세스가\n완료되었음을 메인 스레드에 알려주고, 그에 대한 반응으로 메인 스레드는 AppRegistry(JS Module)를 사용해서 JavaScript 스레드가\n메인 커스텀 컴포넌트(일반적으로 App.js)를 처리하도록 요청합니다.\n스레드 관점에서 요약하면 React Native 앱의 실행 과정은 다음과 같습니다.")]),a._v(" "),e("base-img",{staticStyle:{"margin-bottom":"20px"},attrs:{src:"rn-start-rootin.png"}}),a._v(" "),e("p",[a._v("앱의 메인 컴포넌트를 포함하는 JavaScript 컴포넌트 트리를 순환 하면서 UI 컴포넌트를 만날 때마다\nUIManagerModule을 호출하게 됩니다. UI 스레드에서 UIManagerModule은 '네이티브 뷰'를 만들고\n이를 '루트 뷰'에 저장합니다. 이제 앱이 화면에 렌더링 됩니다. 🎉")]),a._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[a._v("C++로 브리지를 구성한 이유")]),a._v(" "),e("p",[a._v("React Native에 의해 브리지(bridge) 될 필요가 있는 갭(gap)은 2가지 입니다.")]),a._v(" "),e("ol",[e("li",[a._v("언어 갭(Native, JavaScript)")]),a._v(" "),e("li",[a._v("스레드 갭(메인 스레드, NativeModules 스레드, JavaScript 스레드)")])]),a._v(" "),e("p",[a._v("Native, JavaScript 간의 언어 문제는 C++ 환경에서 모두 접근 가능한 JavaScript 글로벌 객체를 가지고 처리합니다.\n결과적으로 React Native에서 '브리지'를 호출하는 것은 서로 다른 스레드로 일을 디스패치 하는 걸 처리하기 위해서 필요할 뿐입니다.\n그런 점에서 'Navtive에서 JavaScript로', 'JavaScript에서 Native로' 라는 이름은 모두 동일한 언어로 구현되었지만 완벽한 의미를 갖습니다.")]),a._v(" "),e("p",[a._v("1번째 스레드는 메인 스레드(또는 NativeModule 스레드)에서 호출 되어 JavaScript 스레드로 전달합니다."),e("br"),a._v("\n2번째 스레드는 JavaScript 스레드(global.flushQueue()함수 사용)에서 호출 되고 호출을 Native 스레드로 디스패치 합니다.")])]),a._v(" "),e("h2",{attrs:{id:"참고"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#참고","aria-hidden":"true"}},[a._v("#")]),a._v(" 참고")]),a._v(" "),e("p",[a._v("Nicolas Couvrat의 React Native 앱이 시작될 때 일어나는 일에 대한 내용을 번역한 것입니다.")]),a._v(" "),e("iframe-wrapper",{attrs:{src:"http://bit.ly/2HVUQRL"}})],1)},[],!1,null,null,null);t.default=v.exports}}]);